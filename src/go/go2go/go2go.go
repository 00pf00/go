// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package go2go rewrites polymorphic code into non-polymorphic code.
package go2go

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// rewritePrefix is what we put at the start of each newly generated .go file.
const rewritePrefix = "// Code generated by go2go; DO NOT EDIT.\n\n"

// Rewrite rewrites the contents of a single directory.
// It looks for all files with the extension .go2, and parses
// them as a single package. It writes out a .go file with any
// polymorphic code rewritten into normal code.
func Rewrite(dir string) error {
	go2files, gofiles, err := go2Files(dir)
	if err != nil {
		return err
	}

	fset := token.NewFileSet()
	pkgs, err := parseFiles(dir, go2files, fset)
	if err != nil {
		return err
	}

	type fileAST struct {
		name string
		ast  *ast.File
	}
	type gpkg struct {
		tpkg     *types.Package
		pkgfiles []fileAST
		info     *types.Info
	}

	var tpkgs []*gpkg
	for name, pkg := range pkgs {
		pkgfiles := make([]fileAST, 0, len(pkg.Files))
		for n, f := range pkg.Files {
			pkgfiles = append(pkgfiles, fileAST{n, f})
		}
		sort.Slice(pkgfiles, func(i, j int) bool {
			return pkgfiles[i].name < pkgfiles[j].name
		})

		asts := make([]*ast.File, 0, len(pkgfiles))
		for _, a := range pkgfiles {
			asts = append(asts, a.ast)
		}

		conf := types.Config{Importer: importer.Default()}
		info := &types.Info{
			Types: make(map[ast.Expr]types.TypeAndValue),
			Defs:  make(map[*ast.Ident]types.Object),
			Uses:  make(map[*ast.Ident]types.Object),
		}
		tpkg, err := conf.Check(name, fset, asts, info)
		if err != nil {
			return fmt.Errorf("type checking failed for %s: %v", name, err)
		}

		tpkgs = append(tpkgs, &gpkg{
			tpkg:     tpkg,
			pkgfiles: pkgfiles,
			info:     info,
		})
	}

	if err := checkAndRemoveGofiles(dir, gofiles); err != nil {
		return err
	}

	for _, tpkg := range tpkgs {
		idToFunc := make(map[types.Object]*ast.FuncDecl)
		idToTypeSpec := make(map[types.Object]*ast.TypeSpec)
		for _, pkgfile := range tpkg.pkgfiles {
			addIDs(tpkg.info, pkgfile.ast, idToFunc, idToTypeSpec)
		}

		for _, pkgfile := range tpkg.pkgfiles {
			if err := rewriteFile(dir, fset, tpkg.info, idToFunc, idToTypeSpec, pkgfile.name, pkgfile.ast); err != nil {
				return err
			}
		}
	}

	return nil
}

// RewriteBuffer rewrites the contents of a single file, in a buffer.
// It returns a modified buffer. The filename parameter is only used
// for error messages.
func RewriteBuffer(filename string, file []byte) ([]byte, error) {
	fset := token.NewFileSet()
	pf, err := parser.ParseFile(fset, filename, file, 0)
	if err != nil {
		return nil, err
	}
	conf := types.Config{Importer: importer.Default()}
	info := &types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
		Defs:  make(map[*ast.Ident]types.Object),
		Uses:  make(map[*ast.Ident]types.Object),
	}
	if _, err := conf.Check(pf.Name.Name, fset, []*ast.File{pf}, info); err != nil {
		return nil, fmt.Errorf("type checking failed for %s: %v", pf.Name.Name, err)
	}
	idToFunc := make(map[types.Object]*ast.FuncDecl)
	idToTypeSpec := make(map[types.Object]*ast.TypeSpec)
	addIDs(info, pf, idToFunc, idToTypeSpec)
	if err := rewriteAST(fset, info, idToFunc, idToTypeSpec, pf); err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	fmt.Fprintln(&buf, rewritePrefix)
	if err := config.Fprint(&buf, fset, pf); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// go2Files returns the list of files in dir with a .go2 extension
// and a list of files with a .go extension.
// This returns an error if it finds any .go files that do not start
// with rewritePrefix.
func go2Files(dir string) (go2files []string, gofiles []string, err error) {
	f, err := os.Open(dir)
	if err != nil {
		return nil, nil, err
	}
	defer f.Close()

	files, err := f.Readdirnames(0)
	if err != nil {
		return nil, nil, fmt.Errorf("reading directory %s: %w", dir, err)

	}

	go2files = make([]string, 0, len(files))
	gofiles = make([]string, 0, len(files))
	for _, f := range files {
		switch filepath.Ext(f) {
		case ".go2":
			go2files = append(go2files, f)
		case ".go":
			gofiles = append(gofiles, f)
		}
	}

	return go2files, gofiles, nil
}

// checkAndRemoveGofiles looks through all the .go files.
// Any .go file that starts with rewritePrefix is removed.
// Any other .go file is reported as an error.
// This is intended to make it harder for go2go to break a
// traditional Go package.
func checkAndRemoveGofiles(dir string, gofiles []string) error {
	for _, f := range gofiles {
		if err := checkGoFile(dir, f); err != nil {
			return err
		}
		if err := os.Remove(filepath.Join(dir, f)); err != nil {
			return err
		}
	}
	return nil
}

// checkGofile reports an error if the file does not start with rewritePrefix.
func checkGoFile(dir, f string) error {
	o, err := os.Open(filepath.Join(dir, f))
	if err != nil {
		return err
	}
	defer o.Close()
	var buf [100]byte
	n, err := o.Read(buf[:])
	if n > 0 && !strings.HasPrefix(string(buf[:n]), rewritePrefix) {
		return fmt.Errorf("Go file %s was not created by go2go", f)
	}
	if err != nil && err != io.EOF {
		return err
	}
	return nil
}

// parseFiles parses a list of .go2 files.
func parseFiles(dir string, go2files []string, fset *token.FileSet) (map[string]*ast.Package, error) {
	pkgs := make(map[string]*ast.Package)
	for _, go2f := range go2files {
		filename := filepath.Join(dir, go2f)
		pf, err := parser.ParseFile(fset, filename, nil, 0)
		if err != nil {
			return nil, err
		}

		name := pf.Name.Name
		pkg, ok := pkgs[name]
		if !ok {
			pkg = &ast.Package{
				Name:  name,
				Files: make(map[string]*ast.File),
			}
			pkgs[name] = pkg
		}
		pkg.Files[filename] = pf
	}
	return pkgs, nil
}
