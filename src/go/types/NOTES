TODO
- if type parameters are repeated in recursive instantiation, they must be the same order (not yet checked)
- implement contract embedding
- interface embedding doesn't take care of literal type constraints yet
  (need an allTypes list, like we have an allMethods list?)
- type assertions on/against parameterized types

OPEN ISSUES
- using a contract and enumerating type arguments currently leads to an error (e.g. func f(type T C(T)) (x T) ... )
- contracts slip through in places where only types are permitted
- parameterized interface methods (of type bounds) need to be customized (subst) for context

DESIGN/IMPLEMENTATION DECISIONS
- 12/4/2019: do not allow parenthesized generic uninstantiated types (unless instantiated implicitly)
  In other words: generic types must always be instantiated before they can be used in any form
  More generally: Only permit type instantiation T(x) in type context, when the type is a named type.
  Do not permit it in general in type context: e.g., disallow []T(x) because we consider that a
  conversion, in general. Same for ([]T)(x).

- 12/12/2019: represent type bounds always as (possibly unnamed) interfaces
  (contracts are user syntactic sugar)
